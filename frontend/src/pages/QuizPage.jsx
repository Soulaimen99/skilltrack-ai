import {useEffect, useState} from "react";
import {useNavigate, useParams} from "react-router-dom";
import useFetch from "../hooks/useFetch";
import QuizQuestion from "../components/QuizQuestion";
import LoadingSpinner from "../components/LoadingSpinner";
import ErrorMessage from "../components/ErrorMessage";

/**
 * Renders the QuizPage component for managing the entire lifecycle of a quiz, including fetching, displaying, answering questions, and completing the quiz.
 *
 * This component handles:
 * - Fetching quiz data using the provided quiz ID.
 * - Displaying the current question and navigation between questions.
 * - Submitting answers for each question.
 * - Completing the entire quiz when all questions are answered.
 * - Showing a detailed summary and review of the completed quiz.
 *
 * @return {JSX.Element} The rendered UI for the quiz page including progress, current question, and quiz completion options.
 */
export default function QuizPage() {
	const { quizId } = useParams();
	const navigate = useNavigate();
	const { get, post, put, loading, error } = useFetch();

	const [quiz, setQuiz] = useState( null );
	const [currentQuestionIndex, setCurrentQuestionIndex] = useState( 0 );
	const [submittingAnswer, setSubmittingAnswer] = useState( false );
	const [completingQuiz, setCompletingQuiz] = useState( false );

	// Questions are generated by AI when the quiz is created

	// Fetch quiz data
	useEffect( () => {
		console.log( "QuizPage - Component mounted or quizId changed:", quizId );
		const fetchQuiz = async () => {
			try {
				const data = await get( `/api/quizzes/${quizId}` );
				setQuiz( data );

				// Find the first unanswered question
				if ( data.questions && data.questions.length > 0 ) {
					const firstUnansweredIndex = data.questions.findIndex( q => !q.answer );
					const startIndex = firstUnansweredIndex >= 0 ? firstUnansweredIndex : 0;
					setCurrentQuestionIndex( startIndex );
				}
			}
			catch {
				console.error( "QuizPage - Error fetching quiz data" );
				// Error is handled by useFetch
			}
		};

		if ( quizId ) {
			fetchQuiz();
		}
	}, [quizId, get] );

	// Handle submitting an answer
	const handleSubmitAnswer = async ( answerData ) => {
		if ( !quiz || submittingAnswer ) return;

		console.log( "QuizPage - Submitting answer for question ID:", answerData.questionId, "Answer:", answerData.answer );
		setSubmittingAnswer( true );
		try {
			const updatedQuiz = await post(
				`/api/quizzes/${quizId}/questions/${answerData.questionId}/answer`,
				{ answer: answerData.answer }
			);
			setQuiz( updatedQuiz );

			// Move to the next unanswered question
			if ( updatedQuiz.questions ) {
				const nextUnansweredIndex = updatedQuiz.questions.findIndex(
					( q, index ) => index > currentQuestionIndex && !q.answer
				);

				if ( nextUnansweredIndex >= 0 ) {
					setCurrentQuestionIndex( nextUnansweredIndex );
				}
				else {
					console.log( "QuizPage - No more unanswered questions found" );
				}
			}
		}
		catch {
			console.error( "QuizPage - Error submitting answer" );
			// Error is handled by useFetch
		}
		finally {
			setSubmittingAnswer( false );
		}
	};

	// Handle completing the quiz
	const handleCompleteQuiz = async () => {
		if ( !quiz || completingQuiz ) return;

		console.log( "QuizPage - Completing quiz with ID:", quizId );
		setCompletingQuiz( true );
		try {
			const updatedQuiz = await put( `/api/quizzes/${quizId}/complete` );
			setQuiz( updatedQuiz );
		}
		catch {
			console.error( "QuizPage - Error completing quiz" );
			// Error is handled by useFetch
		}
		finally {
			setCompletingQuiz( false );
		}
	};

	// Get current question
	const currentQuestion = quiz?.questions?.[currentQuestionIndex] || null;

	// Check if all questions are answered
	const allQuestionsAnswered = quiz?.questions?.every( q => q.answer ) || false;

	// Calculate progress
	const answeredCount = quiz?.questions?.filter( q => q.answer ).length || 0;
	const totalQuestions = quiz?.questions?.length || 0;
	const progressPercentage = totalQuestions > 0 ? (answeredCount / totalQuestions) * 100 : 0;

	if ( loading && !quiz ) {
		return <LoadingSpinner label="Loading quiz..."/>;
	}

	if ( error ) {
		return <ErrorMessage message={error}/>;
	}

	if ( !quiz ) {
		return <p>Quiz not found.</p>;
	}

	return (
		<div className="container">
			<div className="quiz-header">
				<h2>{quiz.goalTitle} Quiz</h2>
				<button
					className="back-button"
					onClick={() => navigate( "/quizzes" )}
				>
					Back to Quizzes
				</button>
			</div>

			{quiz.completed ? (
				<div className="quiz-completed">
					<div className="quiz-summary">
						<h3>Quiz Completed</h3>
						<p className="quiz-score">Score: {quiz.score}</p>
						<p className="quiz-feedback">{quiz.feedback}</p>
						<p>
							Completed on: {new Date( quiz.endedAt ).toLocaleString()}
						</p>
						{quiz.duration > 0 && (
							<p>
								Duration: {Math.floor( quiz.duration / 60 )} min {quiz.duration % 60} sec
							</p>
						)}
					</div>

					<div className="quiz-questions-review">
						<h3>Questions Review</h3>
						{quiz.questions.map( ( question, index ) => (
							<div key={question.id} className="quiz-question-review">
								<h4>Question {index + 1}</h4>
								<QuizQuestion
									question={question}
									readOnly={true}
								/>
							</div>
						) )}
					</div>
				</div>
			) : (
				<div className="quiz-in-progress">
					<div className="quiz-header-actions" style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						marginBottom: '20px'
					}}>
						<div className="quiz-progress" style={{ flex: '1' }}>
							<div className="progress-bar" style={{
								height: '10px',
								backgroundColor: '#e0e0e0',
								borderRadius: '5px',
								overflow: 'hidden'
							}}>
								<div
									className="progress-fill"
									style={{
										width: `${progressPercentage}%`,
										height: '100%',
										backgroundColor: '#4caf50'
									}}
								></div>
							</div>
							<span className="progress-text"
							      style={{ fontSize: '14px', color: '#666', marginTop: '5px', display: 'block' }}>
                {answeredCount} of {totalQuestions} questions answered
              </span>
						</div>
					</div>

					{currentQuestion ? (
						<div className="current-question">
							<h3>Question {currentQuestionIndex + 1}</h3>
							<QuizQuestion
								question={currentQuestion}
								onSubmitAnswer={handleSubmitAnswer}
								loading={submittingAnswer}
								readOnly={!!currentQuestion.answer}
							/>

							<div className="question-navigation">
								<button
									onClick={() => setCurrentQuestionIndex( Math.max( 0, currentQuestionIndex - 1 ) )}
									disabled={currentQuestionIndex === 0}
									className="nav-button"
								>
									Previous
								</button>
								<button
									onClick={() => setCurrentQuestionIndex( Math.min( totalQuestions - 1, currentQuestionIndex + 1 ) )}
									disabled={currentQuestionIndex === totalQuestions - 1}
									className="nav-button"
								>
									Next
								</button>
							</div>
						</div>
					) : (
						<p>No questions available.</p>
					)}

					{allQuestionsAnswered && !quiz.completed && (
						<div className="complete-quiz">
							<button
								onClick={handleCompleteQuiz}
								disabled={completingQuiz}
								className="primary-button"
							>
								{completingQuiz ? <LoadingSpinner small label="Completing..."/> : "Complete Quiz"}
							</button>
						</div>
					)}
				</div>
			)}
		</div>
	);
}
